---
title: 02-面向对象设计原则
tags:
  - Java
  - 设计模式
createTime: 2024/11/24 11:09:01
permalink: /article/eohcr138/
---

## 面向对象的设计原则概述

衡量软件质量的重要属性：

- 可维护性（Maintainability）

  指软件能够被理解、改正、适应及扩展的难易程度；

- 可复用性（Reusability）

  指软件能够被重复使用的难易程度。

最常见的 7 个面向对象设计原则：

| 设计原则名称                                         | 定义                                                         | 使用频率 |
| ---------------------------------------------------- | ------------------------------------------------------------ | -------- |
| 单一职责原则（Single Responsibility Principle，SRP） | 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中 | ⭐⭐⭐⭐     |
| 开闭原则（Open-Close Principle，OCP）                | 软件实体应带对扩展开放，对修改关闭                           | ⭐⭐⭐⭐⭐    |
| 里氏代换原则（Liskov Substitution Principle，LSP）   | 所有引用基类的地方必须透明地使用其子类的对象                 | ⭐⭐⭐⭐⭐    |
| 依赖倒转原则（Dependence Inversion Principle，DIP）  | 高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象 | ⭐⭐⭐⭐⭐    |
| 接口隔离原则（Interface Reuse Principle，IRP）       | 客户端不应该依赖那些它不需要的接口                           | ⭐⭐       |
| 合成复用原则（Composite Reuse Principle，CRP）       | 优先使用对象组合，而不是通过继承来达到复用的目的             | ⭐⭐⭐⭐     |
| 迪米特法则（Law of Demeter，LoD）                    | 每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位 | ⭐⭐⭐      |

## 单一职责原则

单一职责原则是最简单的面向对象设计原则，它用于控制类的粒度大小。

> **单一职责原则**：一个对象应该只包含单一的职责，并且该职责被完整的封装在一个类中。
>
> **Single Responsibility Principle(SRP)**: Every object should hava a single responsibility, and that responsibility should be entirely encapsulated by the class.

单一职责原则是实现高内聚、低耦合的指导方阵，它是最简单但又是最难运行的原则。

例如：一个类，既要连接数据库，又要对表格进行操作，又要生成相关的统计图表。对于这个类，我们可以按照单一职责原则，将其拆分成三个类：用于连接数据库的工具类，用于操作数据库表的 DAO 类，用于生成图表并展示的类。

## 开闭原则

开闭原则是面向对象的可复用设计的第一块基石，是最重要的面向对象设计原则。

> **开闭原则**：软件实体应当对扩展开放，对修改关闭。
>
> **Open-Close Principle(OCP)**: Software entities should be open for extension, but closed for modification.

开闭原则就是指软件实体应尽量在不修改原有代码的情况下进行扩展。

为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。

很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。

## 里氏代换原则

以 Barbara Liskov（芭芭拉·利斯科夫）教授的姓氏命名，其严格表述如下：如果对每一个类型为 S 的对象 o1 都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 都代换 o2 时程序 P 的行为没有变化，那么类型 S 是类型 T 的子类型。

这个原始的定义不太容易理解，一般使用它的另一个通俗版定义：

> **里氏代换原则**：所有引用基类的地方必须能透明地使用其子类的对象。
>
> **Liskov Subsitution Principle (LSP)**: Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.

里氏代换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。

里氏代换原则是实现开闭原则的重要方式之一，由于在使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。

## 依赖倒转原则

依赖倒转原则是面向对象设计的主要实现机制之一，是系统抽象化的具体实现。

> **依赖倒转原则**：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。
>
> Dependence Inversion Principle(DIP): High level modules should not depend upon low level modules, both should depend upon abstractions. Abstractions should not depend upon details, details should depend upon abstractions.

简单来说，依赖倒转原则要求针对接口编程，不要针对实现编程。

依赖倒转原则要求在程序代码中传递参数时或在关联关系中尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，疯狗则将无法调用到在子类中增加的新方法。

在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有的系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。

在实现依赖倒转原则时需要针对抽象层编程，而将具体类的对象通过依赖注入（Dependence Injection, DI）的方式注入到其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，采用抽象的形式来注入所依赖的对象。常用的注入方式有 3 种，分别是构造注入、设值（Setter） 注入和接口注入。

- 构造注入是指通过构造函数来传入具体类的对象。
- 设值注入是指通过 Setter 方法来传入具体类的对象。
- 接口注入是指通过在接口种声明的业务方法来传入具体类的对象。

大多数情况下，开闭原则、里氏代换原则和依赖倒转原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站的角度不同而已。

## 接口隔离原则

> **接口隔离原则**：客户端不应该依赖那些它不需要的接口。
>
> **Interface Segregation Principle(ISP)**: Client should not be forced to depend upon interfaces that they do not use.

当一个接口太大时需要将他分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。

在使用接口隔离原则时需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中的接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，在接口中仅包含为某一类用户定值的方法即可，不应该强迫客户依赖于那些他们不用的方法。

## 合成复用原则

合成复用原则又称为组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP），其定义如下：

> **合成复用原则**：优先使用对象组合，而不是通过继承来达到复用的目的。
>
> **Composite Reuse Principle(CRP)**: Favor composition of objects over inheritance as a reuse mechanism.

在复用时尽量使用组合/聚合关系（关联关系），少用继承。

如果两个类之间使“Has-A”的关系，应使用组合或聚合，如果是“Is-A”的关系，可以使用继承。

## 迪米特法则

迪米特法则又称为最少知识原则（Least Knowledge Principle, LKP），其定义如下：

> **迪米特法则**：每一个软件单位对其他单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。
>
> **Law of Demeter(LoD)**: Each unit should have only limited knowledge about other units: only units “closely” related to the current unit.

迪米特法则要求一个软件实体应当尽可能地与其他实体发生相互作用。

迪米特法则还有几种定义形式，包括不要和“陌生人”说话（Don’t talk to strangers.）、只与你的直接朋友通信（Talk only to your immediate friends.）等。在迪米特法则中，对于一个对象，其朋友包括以下几类：

1. 当前对象本身（this）。
2. 以参数形式传入到当前对象方法中的对象。
3. 当前对象的成员对象。
4. 如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。
5. 当前对象所创建的对象。

应用迪米特法则，可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。通过引入一个合理的“第三者”来降低现有对象之间的耦合度。

将迪米特法则应用到系统设计中应注意以下几点：

- 在类的划分上，尽量创建松耦合的类，有利于复用，松耦合的类一旦被修改，不会对关联的类造成太大影响。
- 在类的结构设计的上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；
- 在类的设计上，只要有可能，一个类型应当设计成不变类；
- 在对其他类的引用上，一个对象对其他对象的引用应当降到最低。
