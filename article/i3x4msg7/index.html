<!doctype html><html lang="zh-CN"><head><meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" /><meta name="generator" content="VuePress 2.0.0-rc.20" /><meta name="theme" content="VuePress Theme Plume 1.0.0-rc.138" /><script id="check-mac-os">document.documentElement.classList.toggle('mac', /Mac|iPhone|iPod|iPad/i.test(navigator.platform))</script><script id="check-dark-mode">;(function () {const um= localStorage.getItem('vuepress-theme-appearance') || 'auto';const sm = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;const isDark = um === 'dark' || (um !== 'light' && sm);document.documentElement.dataset.theme = isDark ? 'dark' : 'light';})();</script><link rel="icon" href="/image/favicon.ico"><title>1.Flink学习笔记 | 一个柚子</title><meta name="description" content="一个柚子的博客"><link rel="preload" href="/assets/style-Box7VrGz.css" as="style"><link rel="stylesheet" href="/assets/style-Box7VrGz.css"><link rel="modulepreload" href="/assets/app-k3221GFj.js"><link rel="modulepreload" href="/assets/index.html-BIzsRxn5.js"><link rel="prefetch" href="/assets/index.html-BUzGYcmO.js" as="script"><link rel="prefetch" href="/assets/index.html-CB1DMPgc.js" as="script"><link rel="prefetch" href="/assets/index.html-4opN9Psn.js" as="script"><link rel="prefetch" href="/assets/index.html-C5J-aOjW.js" as="script"><link rel="prefetch" href="/assets/index.html-BvGs911_.js" as="script"><link rel="prefetch" href="/assets/index.html-W-ylOTKi.js" as="script"><link rel="prefetch" href="/assets/index.html-5dbMCqlh.js" as="script"><link rel="prefetch" href="/assets/index.html-Nc9oIcgi.js" as="script"><link rel="prefetch" href="/assets/index.html-kki5V07W.js" as="script"><link rel="prefetch" href="/assets/index.html-C9PUz_ph.js" as="script"><link rel="prefetch" href="/assets/index.html-CZONieA6.js" as="script"><link rel="prefetch" href="/assets/index.html-BNw7Bed9.js" as="script"><link rel="prefetch" href="/assets/index.html-BigejmyL.js" as="script"><link rel="prefetch" href="/assets/index.html-B8ipDPzp.js" as="script"><link rel="prefetch" href="/assets/404.html-CEdnT4lN.js" as="script"><link rel="prefetch" href="/assets/index.html-PM0iYFdj.js" as="script"><link rel="prefetch" href="/assets/index.html-D_RUo1VL.js" as="script"><link rel="prefetch" href="/assets/index.html-BaM3IYd-.js" as="script"><link rel="prefetch" href="/assets/index.html-BMlHJYQT.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-DXWKOczD.js" as="script"><link rel="prefetch" href="/assets/searchBox-default-DiWUnjYp.js" as="script"><link rel="prefetch" href="/assets/SearchBox-CEGNscyC.js" as="script"></head><body><div id="app"><!--[--><!--[--><div class="theme-plume vp-layout" vp-container data-v-1fc9cae9><!--[--><!--[--><!--]--><!--[--><span tabindex="-1" data-v-82b07878></span><a href="#VPContent" class="vp-skip-link visually-hidden" data-v-82b07878> Skip to content </a><!--]--><!----><header class="vp-nav" data-v-1fc9cae9 data-v-db4466d2><div class="vp-navbar" vp-navbar data-v-db4466d2 data-v-220bb5de><div class="wrapper" data-v-220bb5de><div class="container" data-v-220bb5de><div class="title" data-v-220bb5de><div class="vp-navbar-title" data-v-220bb5de data-v-c56d9d5d><a class="vp-link no-icon link title" href="/" data-v-c56d9d5d data-v-4f934dc8><!--[--><!--[--><!--]--><!--[--><!--[--><!--[--><img class="vp-image dark logo" style="" src="/image/favicon.ico" alt data-v-ba4a78ee><!--]--><!--[--><img class="vp-image light logo" style="" src="/image/favicon.ico" alt data-v-ba4a78ee><!--]--><!--]--><!--]--><span data-v-c56d9d5d>一个柚子</span><!--[--><!--]--><!--]--><!----></a></div></div><div class="content" data-v-220bb5de><div class="content-body" data-v-220bb5de><!--[--><!--]--><div class="vp-navbar-search search" data-v-220bb5de><div class="search-wrapper" data-v-5d6375d7><!----><div id="local-search" data-v-5d6375d7><button type="button" class="mini-search mini-search-button" aria-label="搜索文档" data-v-5d6375d7><span class="mini-search-button-container"><span class="mini-search-search-icon vpi-mini-search" aria-label="search icon"></span><span class="mini-search-button-placeholder">搜索文档</span></span><span class="mini-search-button-keys"><kbd class="mini-search-button-key"></kbd><kbd class="mini-search-button-key">K</kbd></span></button></div></div></div><nav aria-labelledby="main-nav-aria-label" class="vp-navbar-menu menu" data-v-220bb5de data-v-fae93b98><span id="main-nav-aria-label" class="visually-hidden" data-v-fae93b98>Main Navigation</span><!--[--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/" tabindex="0" data-v-fae93b98 data-v-a5b3635e data-v-4f934dc8><!--[--><!----><span data-v-a5b3635e>首页</span><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/blog/" tabindex="0" data-v-fae93b98 data-v-a5b3635e data-v-4f934dc8><!--[--><!----><span data-v-a5b3635e>博客</span><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/blog/tags/" tabindex="0" data-v-fae93b98 data-v-a5b3635e data-v-4f934dc8><!--[--><!----><span data-v-a5b3635e>标签</span><!--]--><!----></a><!--]--><!--[--><a class="vp-link no-icon link navbar-menu-link" href="/blog/archives/" tabindex="0" data-v-fae93b98 data-v-a5b3635e data-v-4f934dc8><!--[--><!----><span data-v-a5b3635e>归档</span><!--]--><!----></a><!--]--><!--[--><div class="vp-flyout vp-navbar-menu-group" data-v-fae93b98 data-v-1489b867><button type="button" class="button" aria-haspopup="true" aria-expanded="false" data-v-1489b867><span class="text" data-v-1489b867><!----><!----><span data-v-1489b867>笔记</span><span class="vpi-chevron-down text-icon" data-v-1489b867></span></span></button><div class="menu" data-v-1489b867><div class="vp-menu" data-v-1489b867 data-v-db169e76><div class="items" data-v-db169e76><!--[--><!--[--><div class="vp-menu-link" data-v-db169e76 data-v-77026440><a class="vp-link no-icon link" href="/demo/" data-v-77026440 data-v-4f934dc8><!--[--><!----> 示例<!--]--><!----></a></div><!--]--><!--]--></div><!--[--><!--]--></div></div></div><!--]--><!--]--></nav><!----><div class="vp-navbar-appearance appearance" data-v-220bb5de data-v-b1addd14><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-b1addd14 data-v-993d65ed data-v-049af359><span class="check" data-v-049af359><span class="icon" data-v-049af359><!--[--><span class="vpi-sun sun" data-v-993d65ed></span><span class="vpi-moon moon" data-v-993d65ed></span><!--]--></span></span></button></div><div class="vp-social-links vp-navbar-social-links social-links" data-v-220bb5de data-v-d89d0a33 data-v-942f7225><!--[--><a class="vp-social-link no-icon" href="https://github.com/ShaddockWong" aria-label="github" target="_blank" rel="noopener" data-v-942f7225 data-v-c483cc0d><span class="vpi-social-github" /></a><!--]--></div><div class="vp-flyout vp-navbar-extra extra" data-v-220bb5de data-v-a109fff2 data-v-1489b867><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-1489b867><span class="vpi-more-horizontal icon" data-v-1489b867></span></button><div class="menu" data-v-1489b867><div class="vp-menu" data-v-1489b867 data-v-db169e76><!----><!--[--><!--[--><!----><div class="group" data-v-a109fff2><div class="item appearance" data-v-a109fff2><p class="label" data-v-a109fff2>外观</p><div class="appearance-action" data-v-a109fff2><button class="vp-switch vp-switch-appearance" type="button" role="switch" title aria-checked="false" data-v-a109fff2 data-v-993d65ed data-v-049af359><span class="check" data-v-049af359><span class="icon" data-v-049af359><!--[--><span class="vpi-sun sun" data-v-993d65ed></span><span class="vpi-moon moon" data-v-993d65ed></span><!--]--></span></span></button></div></div></div><div class="group" data-v-a109fff2><div class="item social-links" data-v-a109fff2><div class="vp-social-links social-links-list" data-v-a109fff2 data-v-942f7225><!--[--><a class="vp-social-link no-icon" href="https://github.com/ShaddockWong" aria-label="github" target="_blank" rel="noopener" data-v-942f7225 data-v-c483cc0d><span class="vpi-social-github" /></a><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="vp-navbar-hamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="nav-screen" data-v-220bb5de data-v-6d2cb7cf><span class="container" data-v-6d2cb7cf><span class="top" data-v-6d2cb7cf></span><span class="middle" data-v-6d2cb7cf></span><span class="bottom" data-v-6d2cb7cf></span></span></button></div></div></div></div><div class="divider" data-v-220bb5de><div class="divider-line" data-v-220bb5de></div></div></div><!----></header><div class="vp-local-nav fixed reached-top is-blog" data-v-1fc9cae9 data-v-efadfaed><button class="hidden menu" disabled aria-expanded="false" aria-controls="SidebarNav" data-v-efadfaed><span class="vpi-align-left menu-icon" data-v-efadfaed></span><span class="menu-text" data-v-efadfaed>Menu</span></button><div class="vp-local-nav-outline-dropdown" style="--vp-vh:0px;" data-v-efadfaed data-v-224bf1bc><button data-v-224bf1bc>返回顶部</button><!----></div></div><!----><!--[--><div id="VPContent" vp-content class="vp-content" data-v-1fc9cae9 data-v-69308628><div class="vp-doc-container is-blog" data-v-69308628 data-v-560bc32b><!--[--><!--]--><div class="container" data-v-560bc32b><!----><div class="content" data-v-560bc32b><div class="content-container" data-v-560bc32b><!--[--><!--]--><main class="main" data-v-560bc32b><nav class="vp-breadcrumb" data-v-560bc32b data-v-acdb1f75><ol vocab="https://schema.org/" typeof="BreadcrumbList" data-v-acdb1f75><!--[--><li property="itemListElement" typeof="ListItem" data-v-acdb1f75><a class="vp-link no-icon link breadcrumb" href="/" property="item" typeof="WebPage" data-v-acdb1f75 data-v-4f934dc8><!--[-->首页<!--]--><!----></a><span class="vpi-chevron-right" data-v-acdb1f75></span><meta property="name" content="首页" data-v-acdb1f75><meta property="position" content="1" data-v-acdb1f75></li><li property="itemListElement" typeof="ListItem" data-v-acdb1f75><a class="vp-link no-icon link breadcrumb" href="/blog/" property="item" typeof="WebPage" data-v-acdb1f75 data-v-4f934dc8><!--[-->博客<!--]--><!----></a><span class="vpi-chevron-right" data-v-acdb1f75></span><meta property="name" content="博客" data-v-acdb1f75><meta property="position" content="2" data-v-acdb1f75></li><li property="itemListElement" typeof="ListItem" data-v-acdb1f75><a class="vp-link no-icon link breadcrumb" href="/blog/categories/?id=4b803b" property="item" typeof="WebPage" data-v-acdb1f75 data-v-4f934dc8><!--[-->大数据<!--]--><!----></a><span class="vpi-chevron-right" data-v-acdb1f75></span><meta property="name" content="大数据" data-v-acdb1f75><meta property="position" content="3" data-v-acdb1f75></li><li property="itemListElement" typeof="ListItem" data-v-acdb1f75><a class="vp-link no-icon link breadcrumb" href="/blog/categories/?id=462329" property="item" typeof="WebPage" data-v-acdb1f75 data-v-4f934dc8><!--[-->Flink<!--]--><!----></a><span class="vpi-chevron-right" data-v-acdb1f75></span><meta property="name" content="Flink" data-v-acdb1f75><meta property="position" content="4" data-v-acdb1f75></li><li property="itemListElement" typeof="ListItem" data-v-acdb1f75><a class="vp-link no-icon link breadcrumb current" href="/article/i3x4msg7/" property="item" typeof="WebPage" data-v-acdb1f75 data-v-4f934dc8><!--[-->1.Flink学习笔记<!--]--><!----></a><!----><meta property="name" content="1.Flink学习笔记" data-v-acdb1f75><meta property="position" content="5" data-v-acdb1f75></li><!--]--></ol></nav><!--[--><h1 class="vp-doc-title page-title" data-v-b2337b26>1.Flink学习笔记 <!----></h1><div class="vp-doc-meta" data-v-b2337b26><p class="reading-time" data-v-b2337b26><span class="vpi-books icon" data-v-b2337b26></span><span data-v-b2337b26>约 6078 字</span><span data-v-b2337b26>大约 20 分钟</span></p><p data-v-b2337b26><span class="vpi-tag icon" data-v-b2337b26></span><!--[--><a class="vp-link no-icon link tag vp-tag-xpd4" href="/blog/tags/?tag=大数据" data-v-b2337b26 data-v-4f934dc8><!--[-->大数据<!--]--><!----></a><a class="vp-link no-icon link tag vp-tag-0imp" href="/blog/tags/?tag=Flink" data-v-b2337b26 data-v-4f934dc8><!--[-->Flink<!--]--><!----></a><!--]--></p><p class="create-time" data-v-b2337b26><span class="vpi-clock icon" data-v-b2337b26></span><span data-v-b2337b26>2024-12-27</span></p></div><!--]--><div class="_article_i3x4msg7_ external-link-icon-enabled vp-doc plume-content" vp-content data-v-560bc32b><div data-v-560bc32b><h2 id="flink是什么" tabindex="-1"><a class="header-anchor" href="#flink是什么"><span>Flink是什么</span></a></h2><p>Apache Flink是一个框架和分布式处理引擎，用于对无界和有界数据流进行状态计算。</p><h2 id="为什么选择flink" tabindex="-1"><a class="header-anchor" href="#为什么选择flink"><span>为什么选择Flink</span></a></h2><p>流数据更真实的反映了我们的生活方式</p><p>传统的数据架构是基于有限数据集的</p><p>目标：</p><ul><li>低延迟</li><li>高吞吐</li><li>结果的准确性和良好的容错性</li></ul><h2 id="流数据适用场景" tabindex="-1"><a class="header-anchor" href="#流数据适用场景"><span>流数据适用场景</span></a></h2><ul><li><p>电商和市场营销</p></li><li><p>数据报表、广告投放、业务流程需要</p></li><li><p>物联网（IOT）</p></li><li><p>传感器实时数据采集和显示、实时报警、交通运输业</p></li><li><p>电信业</p></li><li><p>基站流量调配</p></li><li><p>银行和金融业</p></li><li><p>实时结算和通知推送，实时检测异常行为</p></li></ul><h2 id="传统数据处理架构" tabindex="-1"><a class="header-anchor" href="#传统数据处理架构"><span>传统数据处理架构</span></a></h2><ul><li>事务处理</li></ul><p><img src="/assets/1621387023240-311a30c6-f48f-4db0-b33a-ff8a58e08cb4-DU65Gi2H.png" alt="img"></p><p>特点：实时性高；并发能力差</p><ul><li>分析处理</li></ul><p><img src="/assets/1621387172783-c3fd9302-2ee1-4689-ad07-c140878f3668-BoaahTpq.png" alt="img"></p><p>将数据从业务数据库复制到数仓，再进行分析和查询</p><p>特点：实时性低，并发能力高</p><h2 id="有状态的流式处理" tabindex="-1"><a class="header-anchor" href="#有状态的流式处理"><span>有状态的流式处理</span></a></h2><p><img src="/assets/1621387469994-53bec4cd-6753-4dfa-9f3e-62d2482c85cc-Blbp6UIV.png" alt="img"></p><h2 id="流处理的演变" tabindex="-1"><a class="header-anchor" href="#流处理的演变"><span>流处理的演变</span></a></h2><ul><li>lambda架构</li></ul><p>用两套系统，同时保证低延迟和结果准群</p><p><img src="/assets/1621387790131-e09b5472-08c4-4d87-948a-a8384d0cb8e8-BwbYpko3.png" alt="img"></p><ul><li>Flink</li></ul><p><img src="/assets/1621387904470-3a35451b-bb96-44b4-a0cc-e776885da643-PMmY8bSg.png" alt="img"></p><h2 id="flink主要特点" tabindex="-1"><a class="header-anchor" href="#flink主要特点"><span>Flink主要特点</span></a></h2><ul><li><p>事件驱动（Event-driven）</p></li><li><p>基于流的世界观</p></li><li><p>一切都是由流组成的，离线数据是有界的流；实时数据是一个没有界线的流。</p></li><li><p>分层API</p></li><li><p>越顶层越抽象，表达含义越简明，使用越方便</p></li><li><p>越底层越具体，表达能力越丰富，使用越灵活</p></li></ul><p><img src="/assets/1621388427277-949aef6b-990c-4a17-9b6e-91d9db980954-WqSRkitg.png" alt="img"></p><h2 id="flink的其它特点" tabindex="-1"><a class="header-anchor" href="#flink的其它特点"><span>Flink的其它特点</span></a></h2><ul><li>支持事件时间（event-time）和处理事件（processing-time）语义</li><li>精确一次（exactly-once）的状态一致性保证</li><li>低延迟，每秒处理数百万个事件，毫秒级延迟</li><li>与众多常用存储系统的连接</li><li>高可用，动态扩展，实现7*24小时全天候运行</li></ul><h2 id="flink-vs-spark-streaming" tabindex="-1"><a class="header-anchor" href="#flink-vs-spark-streaming"><span>Flink VS Spark Streaming</span></a></h2><ul><li><p>流（stream）和微批处理（micro-batching）</p></li><li><p>数据模型</p></li><li><p>spark采用RDD模型</p></li><li><p>flink具备数据模型是数据流，以及事件序列</p></li><li><p>运行时架构</p></li><li><p>spark是批计算，将DAG划分为不同的stage，一个完成后才可以计算下一个</p></li><li><p>flink是标准的流执行模式，一个事件在一个节点处理完成后可以直接发往下一个节点进行处理</p></li></ul><h2 id="flink部署" tabindex="-1"><a class="header-anchor" href="#flink部署"><span>Flink部署</span></a></h2><h3 id="standalone模式" tabindex="-1"><a class="header-anchor" href="#standalone模式"><span>standalone模式</span></a></h3><h3 id="yarn模式" tabindex="-1"><a class="header-anchor" href="#yarn模式"><span>yarn模式</span></a></h3><ul><li>Session-Cluster模式</li></ul><p>类似与standalone模式，只不过资源由yarn来分配，多个task共用yarn资源</p><ul><li>Pre-Job-Cluster模式</li></ul><p>每个任务单独使用一套资源，总资源由yarn来管理</p><p>注意：Flink的task和solt的关系，需要占用的solt数=所设置的最大并行度=最大的task数</p><h3 id="kubernetes部署" tabindex="-1"><a class="header-anchor" href="#kubernetes部署"><span>Kubernetes部署</span></a></h3><p>略</p><h2 id="运行时架构" tabindex="-1"><a class="header-anchor" href="#运行时架构"><span>运行时架构</span></a></h2><h3 id="flink运行时组件" tabindex="-1"><a class="header-anchor" href="#flink运行时组件"><span>Flink运行时组件</span></a></h3><p><img src="/assets/1624409631593-ced67825-73aa-4881-ac23-d02cc065edab-DZIpKauN.png" alt="img"></p><h4 id="jobmanager" tabindex="-1"><a class="header-anchor" href="#jobmanager"><span>JobManager：</span></a></h4><ul><li>控制一个应用程序执行的主进程。</li><li>JobManager会先接收到要执行的应用程序，这个应用程序包括：作业图（JobGraph）、逻辑数据流图（logical dataflow graph）和打包了所有的类、库和其他资源的jar包。</li><li>JM会把JobGraph转换成一个物理层面的数据流图，这个图被叫做“执行图”（ExecutionGraph），包含了所有可以并发执行的任务。</li><li>JM会向资源管理器（RM）请求执行任务必要的资源，也就是任务管理器（TM）上的插槽（slot）。一旦它获取到的足够的资源，就会将执行图分发到真正运行他们的TM上。在运行过程中，JM会负责所有需要中央协调的操作，比如checkpoints的协调。</li></ul><h4 id="taskmanager" tabindex="-1"><a class="header-anchor" href="#taskmanager"><span>TaskManager：</span></a></h4><ul><li>Flink中的工作进程。 通常在Flink中会有多个TM运行，每一个TM都包含了一定数量的插槽（slot）。插槽的数量限制了TM能够执行的任务数量。</li><li>启动之后，TM会向RM注册他的插槽；收到RM的指令后，TM就会将一个或者多个插槽提供给JM调用。JM就可以向插槽分配任务来执行了。</li><li>在执行过程中，一个TM可以跟其他同一应用程序的TM交换数据。</li></ul><h4 id="resourcemanager" tabindex="-1"><a class="header-anchor" href="#resourcemanager"><span>ResourceManager：</span></a></h4><ul><li>主要负责管理TM的插槽。插槽是Flink中定义的处理资源单元。</li><li>Flink为不同的环境和资源管理工机提供了不同的RM，比如YARN、Mesos、K8s以及standalone部署。</li><li>当JM申请插槽资源时，RM会将有空闲插槽的TM分配给JM。如果RM没有足够的插槽来满足JM的请求，它还可以向资源提供平台发起绘画，以提供启动TM进程的容器。</li></ul><h4 id="dispacher" tabindex="-1"><a class="header-anchor" href="#dispacher"><span>Dispacher：</span></a></h4><ul><li>可以跨作业运行，它为应用提交提供了REST接口。</li><li>当一个应用被提交执行时，分发器就会启动并将应用移交给一个JM。</li><li>Dispatcher也会启动一个Web UI，用来方便的展示和监控作业执行的信息。</li><li>Dispatcher在架构中可能并不是必须的，这取决于应用提交运行的方式。</li></ul><h4 id="任务提交流程" tabindex="-1"><a class="header-anchor" href="#任务提交流程"><span>任务提交流程</span></a></h4><p><img src="/assets/1624429673725-a86288cb-dda2-4ecc-9376-9251e8997693-NDM63OLK.png" alt="img"></p><h4 id="任务提交流程-yarn" tabindex="-1"><a class="header-anchor" href="#任务提交流程-yarn"><span>任务提交流程(YARN)</span></a></h4><h5 id="【重点】-单作业-per-job-模式" tabindex="-1"><a class="header-anchor" href="#【重点】-单作业-per-job-模式"><span>【重点】：单作业（Per-Job）模式</span></a></h5><p>在单作业模式下，Flink集群不会预先启动，而是在提交作业时，才启动新的JobManager。</p><p><img src="/assets/1659949328788-d3e9809d-13ef-4429-994f-181f71bb5dd6-CJd5aBz3.png" alt="img"></p><ol><li>客户端将作业提交给YARN的资源管理器，这一步中会同时将Flink的Jar包和配置上传到HDFS，以便后续启动Flink相关组件的容器。</li><li>YARN的资源管理器分片Container资源，启动Flink Job Manager，并将作业提交给JobMaster。这里省略了Dispatcher组件。</li><li>JobMaster向资源管理器请求资源（slots）。</li><li>资源管理器向YARN的资源管理器请求container资源。</li><li>YARN启动新的TaskManager容器。</li><li>TaskManager启动之后，向Flink的资源管理器注册自己的可用任务槽。</li><li>资源管理器通知TaskManager为新的作业提供slots。</li><li>TaskManager连接到对应的JobManager为新的作业提供slots。</li><li>JobMaster将需要执行的任务分发给TaskManager，执行任务。</li></ol><h4 id="任务调度原理" tabindex="-1"><a class="header-anchor" href="#任务调度原理"><span>任务调度原理</span></a></h4><p><img src="/assets/1629016481427-40d59bd4-98d1-4ed3-ba4e-ba7361a1e5dd-XJvKJu3x.png" alt="img"></p><p>1、基于代码生成数据流图。</p><p>2、通过客户端提交到flink集群JobManager，生成可执行的执行流图。</p><p>3、tast之间进行数据流交互，执行任务。</p><ul><li><strong>怎样实现并行计算？</strong></li></ul><p>多线程，通过slot，不同的任务开启不同的线程。</p><ul><li><strong>并行的任务，需要占用多少slot？</strong></li></ul><p>默认和每个任务的最大并行度有关，取任务最大并行度。</p><p>如果设置了slotSharingGroup，按各个slot共享组最大并行度累加。</p><ul><li><strong>一个流处理程序，到底包含多少个任务？</strong></li></ul><h5 id="并行度-parallelism" tabindex="-1"><a class="header-anchor" href="#并行度-parallelism"><span>并行度（Parallelism）</span></a></h5><p>一个特定算子的子任务（subtask）的个数被称之为并行度。</p><p>一个流的并行度和当前任务设置的最大并行度相等。</p><h5 id="taskmanager-1" tabindex="-1"><a class="header-anchor" href="#taskmanager-1"><span>taskManager</span></a></h5><p>每一个taskManager都是一个JVM进程，可能会执行一个或多个子任务。</p><p>通过task slot来控制TM能接收多少个task</p><h5 id="slots" tabindex="-1"><a class="header-anchor" href="#slots"><span>Slots</span></a></h5><p>不同slot之间内存内存资源隔离，CPU资源不隔离。</p><p>推荐按照CPU核数分配Slots个数。</p><p>默认情况下，允许子任务共享solt，必须是前后发生的不同任务。一个slot可以保存作业的整个管道。 （提高效率）</p><p>Task Slot是静态的概念，是指TaskManager具有的并发执行能力。</p><h4 id="程序与数据流-dataflow" tabindex="-1"><a class="header-anchor" href="#程序与数据流-dataflow"><span>程序与数据流（DataFlow）</span></a></h4><ul><li>所有的Flink程序都有三步组成：Source、Transformation和Sink。</li><li>dataFlow类似于任意的有向无环图（DAG）</li></ul><h4 id="执行流图-executiongraph" tabindex="-1"><a class="header-anchor" href="#执行流图-executiongraph"><span>执行流图（ExecutionGraph）</span></a></h4><ul><li><p>StreamGraph -&gt; JobGraph -&gt; ExecutionGraph -&gt; 物理执行图</p></li><li><p>StreamGraph：根据StreamAPI代码生成的最初的图。用来表示程序的拓扑结构。</p></li><li><p>JobGraph：提交给JobManager的数据结构。优化：将多个符合条件的任务chain在一起作为一个结点。</p></li><li><p>ExecutionGraph：是JobGraph的并行化版本，是调度层最核心的数据结构。</p></li><li><p>物理执行图：在各个TaskManager上部署task后形成的图，并不是一个具体的数据结构。</p></li></ul><h4 id="数据传输形式" tabindex="-1"><a class="header-anchor" href="#数据传输形式"><span>数据传输形式</span></a></h4><ul><li><p>one-to-one：算子之间不会重分区。例：map、fliter、flatMap等算子。</p></li><li><p>redistribution：stream的分区会发生改变。例：keyBy基于hashCode重分区，broadcast和rebalance（轮询方式）会随机重新分区。redistribution过程就类似于spark中的shuffle。</p></li><li><p>算子.shuffle（洗牌）是完全随机重分区。</p></li></ul><h4 id="任务链-operationn-chains" tabindex="-1"><a class="header-anchor" href="#任务链-operationn-chains"><span>任务链（Operationn chains）</span></a></h4><ul><li>一种优化技术，可以在特点条件下减少本地通信的开销。</li><li>相同并行度的、同一solt共享组的one-to-one操作，可以连接成同一个任务。</li></ul><p><img src="/assets/1629026117175-da1381d5-9b32-4839-bd00-864ebb2ca9d0-BA-BL1FE.png" alt="img"></p><h2 id="flink流处理api" tabindex="-1"><a class="header-anchor" href="#flink流处理api"><span>Flink流处理API</span></a></h2><h3 id="_1、environment" tabindex="-1"><a class="header-anchor" href="#_1、environment"><span>1、Environment</span></a></h3><ol><li><code>getExecutionEnvironment</code>：自动判断从哪里获取环境</li><li><code>createLocalEnvironment</code>：从本地获取环境，需要指定</li><li><code>createRemoteEnvironment</code>：获取远程flink环境</li></ol><h3 id="_2、source" tabindex="-1"><a class="header-anchor" href="#_2、source"><span>2、Source</span></a></h3><ol><li>从集合中读取</li></ol><p><code>env.fromCollection()</code></p><ol><li>从文件读取</li></ol><p><code>env.readTextFile()</code></p><ol><li>从 kafka读取</li></ol><p><code>env.addSource(new FlinkKafkaConsumer011&lt;String&gt;())</code></p><ol><li>自定义source</li></ol><p><code>env.addSource(new MySource)</code></p><p><code>MySource</code>实现<code>SourceFunction&lt;T&gt;</code>;</p><p><code>run()</code>里边可以写生成数据的代码；<code>cancel()</code>里修改控制变量。</p><h3 id="_3、transform" tabindex="-1"><a class="header-anchor" href="#_3、transform"><span>3、Transform</span></a></h3><h4 id="_3-1-map" tabindex="-1"><a class="header-anchor" href="#_3-1-map"><span>3.1 map</span></a></h4><p>对数据进行转换</p><h4 id="_3-2-flatmap" tabindex="-1"><a class="header-anchor" href="#_3-2-flatmap"><span>3.2 flatmap</span></a></h4><p>数据打散转换</p><h4 id="_3-3-filter" tabindex="-1"><a class="header-anchor" href="#_3-3-filter"><span>3.3 filter</span></a></h4><p>对数据进行过滤</p><h4 id="_3-4-keyby" tabindex="-1"><a class="header-anchor" href="#_3-4-keyby"><span>3.4 keyBy</span></a></h4><p>DataStream --&gt; KeyedStrea：逻辑的将一个流拆分成不相交的分区，每个分区包含具有相同key的元素，在内部以hash的形式实现分区。</p><h4 id="_3-5-滚动聚合算子" tabindex="-1"><a class="header-anchor" href="#_3-5-滚动聚合算子"><span>3.5 滚动聚合算子</span></a></h4><ul><li>sum()</li><li>min()</li><li>max()</li><li>minBy()</li><li>maxBy()</li></ul><h4 id="_3-6-reduce" tabindex="-1"><a class="header-anchor" href="#_3-6-reduce"><span>3.6 reduce</span></a></h4><p>keyedStream --&gt; DataStream：一个分组数据流的聚合操作，合并当前元素和上次聚合的结果，产生一个新的值，返回的流中包含每一次聚合的结果，而不是只返回最后一次聚合的最终结果。</p><h4 id="_3-7-split和select" tabindex="-1"><a class="header-anchor" href="#_3-7-split和select"><span>3.7 Split和Select</span></a></h4><p>split：DataStrean --&gt; SplitStream：根据某些特征把一个DataStream拆分成两个或者多个DataStream。</p><p>select：SplitStream --&gt; DataStream：从一个SplitStream中获取一个或者多个DataStream。</p><h4 id="_3-8-connect和comap" tabindex="-1"><a class="header-anchor" href="#_3-8-connect和comap"><span>3.8 Connect和CoMap</span></a></h4><p>Connect：DataStream,DataStream --&gt; ConnectedStreams：连接两个保持他们类型的数据流，两个数据流被Connect之后，<strong>只是被放在了同一个流中</strong>，内部依然保持各自的数据和形式不发生任何变化，两个流相互独立。</p><p>CoMap/CoFlatMap：ConnectedStreams --&gt; DataStream :作用于ConnectedStreams上，功能与map和flatMap一样，对ConnectedStreams中的每一个Stream分别进行map和flatMap处理。</p><h4 id="_3-9-union" tabindex="-1"><a class="header-anchor" href="#_3-9-union"><span>3.9 Union</span></a></h4><p>DataStream --&gt; DataStream ：对两个或着两个以上的DataStream进行union操做，产生一个包含所有DataStream元素的新 DataStream。</p><h3 id="支持的数据类型" tabindex="-1"><a class="header-anchor" href="#支持的数据类型"><span>支持的数据类型</span></a></h3><p>Flink使用类型信息的概念来表示数据类型，并为每个数据类型生成特定的序列化器、反序列化器和比较器。</p><p>Flink还具有一个类型提取系统，该系统分析函数的输入和返回类型，以自动获取类型信息，从而获得序列化器和反序列化器。</p><ol><li>基础数据类型</li><li>java和scala元组（tuple）</li><li>scala样例类</li><li>java简单对象（POJOs）：必须有空参构造，private属性必须有getter和setter</li><li>Arrays，lists，Maps，Enums......</li></ol><h3 id="实现udf函数-更细粒度的控制流" tabindex="-1"><a class="header-anchor" href="#实现udf函数-更细粒度的控制流"><span>实现UDF函数--更细粒度的控制流</span></a></h3><h4 id="_1、函数类-function-classes" tabindex="-1"><a class="header-anchor" href="#_1、函数类-function-classes"><span>1、函数类（Function Classes）</span></a></h4><p>Flink暴露了所有的udf函数的接口。</p><h4 id="_2、匿名函数-lambda-function" tabindex="-1"><a class="header-anchor" href="#_2、匿名函数-lambda-function"><span>2、匿名函数（Lambda Function）</span></a></h4><h4 id="_3、富函数-rich-function" tabindex="-1"><a class="header-anchor" href="#_3、富函数-rich-function"><span>3、富函数（Rich Function）</span></a></h4><p>是DataStream API提供的一个函数类的接口，所有 Flink函数类都有其Rich版本。与常规函数不同，可以获取运行时上下文，并拥有一些生命周期方法，可以实现更复杂的功能。</p><ul><li>RichMapFunction</li><li>RichFlatMapFunction</li><li>RichFilterFunction</li><li>... ...</li></ul><p>生命周期：</p><ul><li>open()方法是richFunction的初始化方法。</li><li>close()是生命周期中最后一个调用的方法，做一些清理工作。</li><li>getRuntimeContext()方法提供了函数RuntimeContext的一些信息，例如函数执行的并行度，任务的名字以及state状态。</li></ul><h3 id="sink" tabindex="-1"><a class="header-anchor" href="#sink"><span>Sink</span></a></h3><p><img src="/assets/1629197874460-16d64c2b-c17b-4336-907f-10dac7745113-DPwTBDCS.png" alt="img"></p><h2 id="flink-中的-window" tabindex="-1"><a class="header-anchor" href="#flink-中的-window"><span>Flink 中的 Window</span></a></h2><h3 id="window-概述" tabindex="-1"><a class="header-anchor" href="#window-概述"><span>Window 概述</span></a></h3><p>window 是一种<strong>切割无限数据为有限块</strong>进行处理的手段。</p><h3 id="window-类型" tabindex="-1"><a class="header-anchor" href="#window-类型"><span>Window 类型</span></a></h3><p>Window 可以分成两类：</p><ul><li>CountWindow： 按照指定的数据条数生成一个 Window，与时间无关。</li><li>TimeWindow： 按照时间生成Window。</li></ul><ol><li>滚动窗口（Tumbling Windows）</li></ol><p>将数据依据固定的窗口长度对数据进行切片。</p><p>特点：时间对齐，窗口长度固定，没有重叠。</p><ol><li>滑动窗口（Sliding Windows）</li></ol><p>滑动窗口是固定窗口的更广义的一种形式，滑动窗口由固定的窗口长度和滑动 间隔组成。</p><p>特 点 ： 时间对齐，窗口长度固定，可以有重叠。</p><ol><li>会话窗口（Session Windows）</li></ol><p>由一系列事件组合一个指定时间长度的 timeout 间隙组成，类似于 web 应用的 session，也就是一段时间没有接收到新数据就会生成新的窗口。</p><p>特点：时间无对齐</p><h3 id="window-api" tabindex="-1"><a class="header-anchor" href="#window-api"><span>Window API</span></a></h3><p>TimeWindow（）</p><p>CountWindow（）</p><h3 id="window-function" tabindex="-1"><a class="header-anchor" href="#window-function"><span>window function</span></a></h3><ul><li>增量聚合函数（incremental aggregation functions）</li></ul><p>每条数据到来就进行计算，保持一个简单的状态。典型的增量聚合函数有 ReduceFunction, AggregateFunction。</p><ul><li>全窗口函数（full window functions）</li></ul><p>先把窗口所有数据收集起来，等到计算的时候会遍历所有数据。 ProcessWindowFunction 就是一个全窗口函数。</p><ul><li>其它可选 API</li></ul><p>.trigger() —— 触发器</p><p>定义window什么时候关闭，触发计算并输出结果</p><p>.evitor() —— 移除器</p><p>定义移除某些数据的逻辑</p><p>.allowedLateness() —— 允许处理迟到的数据</p><p>.sideOutputLateData() —— 将迟到的数据放入侧输出流</p><p>.getSideOutput() —— 获取侧输出流</p><h2 id="时间语义与-wartermark" tabindex="-1"><a class="header-anchor" href="#时间语义与-wartermark"><span>时间语义与 Wartermark</span></a></h2><h3 id="flink-中的时间语义" tabindex="-1"><a class="header-anchor" href="#flink-中的时间语义"><span>Flink 中的时间语义</span></a></h3><p>Event Time：是事件创建的时间。它通常由事件中的时间戳描述，例如采集的日志数据中，每一条日志都会记录自己的生成时间 ，Flink 通过时间戳分配器访问事 件时间戳。</p><p>Ingestion Time：是数据进入 Flink的时间。</p><p>Processing Time：是每一个执行基于时间操作的算子的本地系统时间，与机器相关，默认的时间属性就是 Processing Time。</p><h3 id="eventtime-的引入" tabindex="-1"><a class="header-anchor" href="#eventtime-的引入"><span>EventTime 的引入</span></a></h3><p>在Flink的流式处理中，绝大部分的业务都会使用 eventTime，一般只在 eventTime 无法使用时，才会被迫使用 ProcessingTime 或者 IngestionTime。</p><h3 id="watermark" tabindex="-1"><a class="header-anchor" href="#watermark"><span>Watermark</span></a></h3><ul><li>是一种衡量eventTime进展的机制，可以设定延迟触发</li><li>用于处理乱序事件，通常用watermark机制结合window来实现</li><li>用来让程序平衡延迟和结果正确性</li></ul><h3 id="wm特点" tabindex="-1"><a class="header-anchor" href="#wm特点"><span>WM特点</span></a></h3><ul><li>WM是一条特殊的数据记录</li><li>WM必须是单调递增的，以确保任务的事件时间时钟在向前推进，而不是在后退</li><li>WM与数据的时间戳有关</li></ul><h3 id="wm的传递" tabindex="-1"><a class="header-anchor" href="#wm的传递"><span>WM的传递</span></a></h3><p><img src="/assets/1629198997286-74e94f08-ab8c-43cd-8153-9b1f583c1138-DV35wF_R.png" alt="img"></p><ul><li>上游任务向下游任务广播自己的WM</li><li>下游任务会收到多个分区的不同WM，然后保存起来，判断哪个WM最小</li><li>继续向下游广播最小的WM，如果判断后得到的WM值大于当前广播的WM值，就向下游更新广播的WM，否则不做任何操作</li></ul><h3 id="wm的引入" tabindex="-1"><a class="header-anchor" href="#wm的引入"><span>WM的引入</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//乱序数据设置时间戳和wartermark</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">DataStream</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">assignTimestampsAndWatermarks</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> BoundedOutOfOrdernessTimestampExtractor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">T</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;())</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//升序数据设置时间戳和wartermark</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">DataStream</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">assignTimestampsAndWatermarks</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> AscendingTimestampExtractor</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">T</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;())</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以周期性生成WM或断点式生成WM，自定义生成WM</p><h3 id="wm的设定" tabindex="-1"><a class="header-anchor" href="#wm的设定"><span>WM的设定</span></a></h3><ul><li>WM的延迟设置太久，收到结果的速度就会很慢，解决办法是在水位线到达之前输出的一个近似结果</li><li>如果WM到达的太早，则可能收到错误结果，不过Flink处理迟到数据的机制可以解决这个问题</li></ul><h4 id="断点式生成" tabindex="-1"><a class="header-anchor" href="#断点式生成"><span>断点式生成：</span></a></h4><p>更新watermark快</p><p>数据量大会在同一时间戳会产生大量数据。浪费</p><p>数据稀疏推荐使用</p><h4 id="周期性生成" tabindex="-1"><a class="header-anchor" href="#周期性生成"><span>周期性生成：</span></a></h4><p>更新不及时</p><p>不会产生大量同一时间的WM</p><p>稀疏数据也会生成WM，造成浪费</p><p>数据稠密推荐使用</p><h4 id="窗口起始点" tabindex="-1"><a class="header-anchor" href="#窗口起始点"><span>窗口起始点</span></a></h4><ul><li>获取到数据时间戳之后才分配窗口</li><li>窗口起始时间为：timestamp - timestamp%windowSize</li></ul><h4 id="偏移量" tabindex="-1"><a class="header-anchor" href="#偏移量"><span>偏移量</span></a></h4><p>主要用于处理不同时区的数据，源码有说明</p><p>**flink处理迟到数据：**watermark --&gt; 窗口处理迟到的机制 --&gt; 侧输出流批处理合并</p><h2 id="processfunction-api-底层-api" tabindex="-1"><a class="header-anchor" href="#processfunction-api-底层-api"><span>ProcessFunction API（底层 API）</span></a></h2><p>可以访问时间戳、watermark 以及注册定时事件。还可以输出特定的一些事件。</p><ul><li>ProcessFunction</li><li>KeyedProcessFunction</li><li>CoProcessFunction</li><li>ProcessJoinFunction</li><li>BroadcastProcessFunction</li><li>KeyedBroadcastProcessFunction</li><li>ProcessWindowFunction</li><li>ProcessAllWindowFunction</li></ul><h4 id="keyedprocessfunction" tabindex="-1"><a class="header-anchor" href="#keyedprocessfunction"><span>KeyedProcessFunction</span></a></h4><p>.processElement()</p><p>ctx.timerService()可以在timerService中注册定时事件</p><p>.onTime() --&gt; 定时器</p><p>使用场景:连续10秒温度上升报警</p><h2 id="flink状态管理" tabindex="-1"><a class="header-anchor" href="#flink状态管理"><span>Flink状态管理</span></a></h2><h3 id="状态" tabindex="-1"><a class="header-anchor" href="#状态"><span>状态</span></a></h3><p><img src="/assets/1629202676356-c62ee315-9228-41ea-b4ad-17e238a89c1e-DwCsphQh.png" alt="img"></p><ul><li>由一个任务维护，并且用来计算某个结果的所有数据，都属于这个任务的状态</li><li>可任务状态就是一个本地变量，可以被任务的业务逻辑访问</li><li>flink会进行状态管理，包括状态一致性，故障处理以及高效存储和访问，以便开发人员可以专注于应用的逻辑</li><li>状态始终与特定算子相关联，和特定任务绑定</li><li>算子需要预先注册其状态</li></ul><p>两种类型的状态</p><ul><li><p>算子状态（Operator State）</p></li><li><p>作用范围限定为算子任务</p></li><li><p>键控状态（Keyed State）</p></li><li><p>根据输入数据流中定义的键来维护和访问</p></li></ul><h3 id="算子状态" tabindex="-1"><a class="header-anchor" href="#算子状态"><span>算子状态</span></a></h3><ul><li>作用范围限定为算子任务，由同一并行任务所处理的所有数据都可以访问到相同的状态</li><li>对于同一子任务而言是共享的</li><li>不能由相同或不同算子的另一个子任务访问</li></ul><p><strong>数据结构</strong></p><p>列表状态（list state）</p><ul><li>将状态表示为一组数据的列表</li></ul><p>联合列表状态（union list state ）</p><ul><li>也将状态表示为数据的列表，与常规列表状态的区别在于，发生故障时，或者从保存点（savepoint）启动应用程序时如何恢复</li></ul><p>广播状态（Broadcast state）</p><ul><li>如果一个算子有多项任务，而他的每项任务状态又都相同，那么这种特殊情况最适合应用广播状态</li></ul><h3 id="键控状态" tabindex="-1"><a class="header-anchor" href="#键控状态"><span>键控状态</span></a></h3><ul><li>键控状态根据输入数据流中定义的键来维护和访问</li><li>flink为每个key都维护一个状态实例，并将具有相同键的所有数据，都分区到同一个算子任务中，这个任务会维护和处理这个key对应的状态</li><li>当任务处理一条数据时，他会自动将状态的访问范围限定为当前数据的key</li></ul><p><strong>数据结</strong></p><p>值状态(value state)</p><ul><li>将状态表示为单个值</li></ul><p>列表状态（list state）</p><ul><li>将状态表示为一组数据的列表</li></ul><p>映射状态（Map state）</p><ul><li>将状态表示为一组Key-Value对</li></ul><p>列表状态（Reducing state &amp; Aggregating state）</p><ul><li>将状态表示为一个用于聚合操作的列表</li></ul><p><strong>只能在富函数中使用，需要用到runtimeContext</strong></p><h3 id="状态后端-state-backends" tabindex="-1"><a class="header-anchor" href="#状态后端-state-backends"><span>状态后端（state backends）</span></a></h3><ul><li>状态的存储、访问以及维护，由一个可插入的组件决定，这个组件就叫做状态后端。</li><li>主要负责两件事：本地的状态管理，以及将检查点（checkpoints）状态写入远程存储。</li></ul><h4 id="选择一个状态后端" tabindex="-1"><a class="header-anchor" href="#选择一个状态后端"><span>选择一个状态后端</span></a></h4><ol><li>MemoryStateBackend</li></ol><ul><li>会将状态作为内存中的对象进行管理，将它们存储在TaskManager的JVM堆上，而将checkpoint存储在JobManager的内存中</li><li>特点：快速、低延迟，不稳定</li></ul><ol><li>FsStateBackend</li></ol><ul><li>将checkpoint存储到远程的持久化的文件系统上，而对于本地状态，存储在TaskManager的JVM堆上</li><li>同时拥有内存级的本地访问速度，和更好的容错保证</li></ul><ol><li>RocksDBStateBackend</li></ol><ul><li>将所有状态序列化后，存入本地的RocksDB中存储</li></ul><p>在配置文件中配置</p><p>在env.setStateBackend()设置</p><h2 id="flink容错机制" tabindex="-1"><a class="header-anchor" href="#flink容错机制"><span>flink容错机制</span></a></h2><h3 id="一致性检查点-checkpoints" tabindex="-1"><a class="header-anchor" href="#一致性检查点-checkpoints"><span>一致性检查点（checkpoints）</span></a></h3><ul><li>故障回复机制的核心，就是应用状态的一致性检查点</li><li>由状态流应用的一致性检查点，其实就是所有任务的状态，在某个时间点的一份拷贝（快照）；这个时间点，应该时所有任务都<strong>恰好处理完一个相同输入数据的时候</strong>。</li></ul><h3 id="从检查点恢复状态" tabindex="-1"><a class="header-anchor" href="#从检查点恢复状态"><span>从检查点恢复状态</span></a></h3><ul><li>重启应用</li><li>从checkpoint中读取数据，将状态重置</li><li>开始并处理检查点到发生故障之前的所有数据</li></ul><p>这种检查点的保存和恢复机制可以为应用状态提供“精确一次”（exactly-once）的一致性，因为所有算子都会保存检查点并恢复其所有状态，这样一来所有的输入流就都会被重置到检查点完成时的位置。</p><h3 id="检查点的实现算法" tabindex="-1"><a class="header-anchor" href="#检查点的实现算法"><span>检查点的实现算法</span></a></h3><ul><li>基于Chandy-Lamport算法的分布式快照</li><li>将检查点的保存和数据处理分开，不暂停整个应用</li></ul><h4 id="检查点分界线-checkpoint-barrier" tabindex="-1"><a class="header-anchor" href="#检查点分界线-checkpoint-barrier"><span>检查点分界线（checkpoint barrier）</span></a></h4><ul><li>flink的检查点算法用到了一种称为分界线（barrier）的特殊数据形式，用来把一条流上数据按照不同检查点分开</li><li>分界线之前到来的数据导致的状态更改，都会被包含在当前分界线所属的检查点中；而基于分界线之后的数据导致的所有更改，就会被包含在之后的检查点中</li></ul><h4 id="flink检查点算法" tabindex="-1"><a class="header-anchor" href="#flink检查点算法"><span>flink检查点算法</span></a></h4><p><img src="/assets/1629241612669-29147ce4-9636-494f-a9ef-7beb27fc0326-D2ZBYR6_.png" alt="img"></p><p>一个用两个输入流的应用程序，用并行的两个source任务来读取</p><p><img src="/assets/1629241926999-3d711bc4-1e91-4846-a88f-b30af3790666-DRMDnYu3.png" alt="img"></p><p>JobManager会向每个source任务发送一个带有新检查点ID的消息，通过这种方式来启动检查点。</p><p><img src="/assets/1629241968357-ee3dc79a-381a-45a2-a234-98ada8045b04-BL3K_Zqx.png" alt="img"></p><p>数据源将它们的状态写入检查点，并发出一个检查点barrier。</p><p>状态后端在状态存储检查点之后，会返回通知给sourc任务，source任务就会向jobManager确认检查点完成。</p><p><img src="/assets/1629242308601-056da075-7511-4ad4-8e98-f766862c960f-Ctuj00O4.png" alt="img"></p><p>分界线对齐：barrier向下游传递，sum任务会等待所有输入分区的barrier到达。</p><p>对于barrier已经到达的分区，后续到达的数据会被缓存。</p><p>而barrier未到达的分区，数据会被正常处理。</p><p><img src="/assets/1629242574043-4d809dc5-7de9-47ad-88c1-e0e297dc2be0-4m2w9DYG.png" alt="img"></p><p>当收到所有输入分区的barrier时，任务就将其状态保存到状态后端的检查点中，然后将barrier继续向下游转发。</p><p><img src="/assets/1629242698971-555de10d-626b-4325-89cb-0bc3dbca6dcf-DtMcx7cM.png" alt="img"></p><p>向下游转发检查点barrier后，任务继续正常的数据处理</p><p><img src="/assets/1629242776121-72d0020e-195d-4c32-8d15-258a9c062e7e-D8jEmU6G.png" alt="img"></p><p>sink任务向jobManager确认状态保存到checkpoint完毕。</p><p>当所有任务都确认已成功将状态保存到检查点时，检查点就真正完成了。</p><h3 id="保存点" tabindex="-1"><a class="header-anchor" href="#保存点"><span>保存点</span></a></h3><p>savepoint</p><p>原理和checkpoint相同，需要用户手动设置保存点</p><h3 id="flink状态一致性" tabindex="-1"><a class="header-anchor" href="#flink状态一致性"><span>Flink状态一致性</span></a></h3><p>计算结果要保证准确，一条数据不应该丢失，也不应该重复计算。</p><h4 id="分类" tabindex="-1"><a class="header-anchor" href="#分类"><span>分类</span></a></h4><ul><li>AT-MOST-ONCE(最多一次)</li></ul><p>既不恢复丢失的状态，也不重播丢失的数据</p><ul><li>AT-LEAST-ONCE(至少一次)</li></ul><p>不丢失事件，所有事件都得到了处理，而一些事件还可能被处理多次</p><ul><li>EXACTLY-ONCE(精确一次，恰好一次)</li></ul><p>不仅不丢失，内部状态也仅更新一次</p><h4 id="一致性检查点" tabindex="-1"><a class="header-anchor" href="#一致性检查点"><span>一致性检查点</span></a></h4><p>轻量级快照机制----checkpoint</p><h4 id="端到端-end-to-end-状态一致性" tabindex="-1"><a class="header-anchor" href="#端到端-end-to-end-状态一致性"><span>端到端(end-to-end)状态一致性</span></a></h4><p>内部保证--checkpiont</p><p>source端--可重设数据的读取位置</p><p>sink端--不会重复写入外部系统</p><ul><li>幂等写入</li></ul><p>可以重复执行很多次，但只导致一次结果改正。保证最终结果一致。</p><p>eg.HashMap</p><ul><li>事务写入</li></ul><p>实现思想：构建的事务对应着checkpoint，等到checkpoint真正完成的时候，才把所有对应的结果写入sink系统中。</p><p>实现方式：</p><ol><li>预写日志 WAL</li><li>两阶段提交 2PC</li></ol><h4 id="wal" tabindex="-1"><a class="header-anchor" href="#wal"><span>WAL</span></a></h4><p>简单易于实现，但是会增大延迟，不能完全保证。</p><p>DateStream API:GenericWriteAheadSink</p><h4 id="_2pc" tabindex="-1"><a class="header-anchor" href="#_2pc"><span>2PC</span></a></h4><p>对于每个checkpoint，sink任务都会启动一个事务。</p><p>先预提交，当收到checkpoint完成的通知时，才正式提交事务。</p><p>TowPhaseCommitSinkFunction接口可实现</p><h4 id="flink-kafka端到端状态一致性特征" tabindex="-1"><a class="header-anchor" href="#flink-kafka端到端状态一致性特征"><span>flink-kafka端到端状态一致性特征</span></a></h4><ul><li>内部--checkpoint</li><li>source--将偏移量保存下来</li><li>sink--采用两阶段提交sink，需要实现一个TowPhaProcessFunction</li></ul><p>两段事务超时时间必须匹配</p></div><!----><!----><!----></div></main><footer class="vp-doc-footer" data-v-560bc32b data-v-c857328b><!--[--><!--]--><div class="edit-info" data-v-c857328b><div class="edit-link" data-v-c857328b><a class="vp-link no-icon link edit-link-button" href="https://github.com/ShaddockWong/edit/main/docs/3.大数据/1.Flink/1.Flink学习笔记.md" target="_blank" rel="noreferrer" data-v-c857328b data-v-4f934dc8><!--[--><span class="vpi-square-pen edit-link-icon" aria-label="edit icon" data-v-c857328b></span> 编辑此页<!--]--><!----></a></div><!----></div><div class="contributors" aria-label="Contributors" data-v-c857328b><span class="contributors-label" data-v-c857328b>贡献者: </span><span class="contributors-info" data-v-c857328b><!--[--><!--[--><span class="contributor" data-v-c857328b>ShaddockWong</span><!----><!--]--><!--]--></span></div><nav class="prev-next" data-v-c857328b><div class="pager" data-v-c857328b><a class="vp-link no-icon link pager-link prev" href="/article/t9ghyrme/" data-v-c857328b data-v-4f934dc8><!--[--><span class="desc" data-v-c857328b>上一页</span><span class="title" data-v-c857328b>linux sar 命令详解(历史资源查看，如内存、CUP等等)</span><!--]--><!----></a></div><div class="pager" data-v-c857328b><a class="vp-link no-icon link pager-link next" href="/article/avjuo0xw/" data-v-c857328b data-v-4f934dc8><!--[--><span class="desc" data-v-c857328b>下一页</span><span class="title" data-v-c857328b>07-原型模式</span><!--]--><!----></a></div></nav></footer><!----><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!--]--><button style="display:none;" type="button" class="vp-back-to-top" aria-label="back to top" data-v-1fc9cae9 data-v-dec48c97><span class="percent" data-allow-mismatch data-v-dec48c97>0%</span><span class="show icon vpi-back-to-top" data-v-dec48c97></span><svg aria-hidden="true" data-v-dec48c97><circle cx="50%" cy="50%" data-allow-mismatch style="stroke-dasharray:calc(0% - 12.566370614359172px) calc(314.1592653589793% - 12.566370614359172px);" data-v-dec48c97></circle></svg></button><footer class="vp-footer" vp-footer data-v-1fc9cae9 data-v-55c60c4a><!--[--><div class="container" data-v-55c60c4a><p class="message" data-v-55c60c4a>Powered by <a target="_blank" href="https://v2.vuepress.vuejs.org/">VuePress</a> & <a target="_blank" href="https://theme-plume.vuejs.press">vuepress-theme-plume</a></p><!----></div><!--]--></footer><!--[--><!--]--><!--]--></div><!----><!--]--><!--[--><!--]--><!--]--></div><script type="module" src="/assets/app-k3221GFj.js" defer></script></body></html>